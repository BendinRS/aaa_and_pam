# Домашняя работа "PAM"

### Запретить всем пользователям, кроме группы admin логин в выходные (суббота и воскресенье), без учета праздников

+ Создаем трех пользователей:  
● ”day” - имеет удаленный доступ каждый день с 8 до 20;  
● “night” - с 20 до 8;  
● “friday” - в любое время, если сегодня пятница.  

![Альтернативный текст](https://i.ibb.co/SB5k0wc/1234.png)

+ Стенд готов к выполнению ЛР

<details>
  <summary>Про PAM</summary>
  
  PAM (Pluggable Authentication Modules - подключаемые модули
аутентификации) - это набор библиотек, которые позволяют
интегрировать различные методы аутентификации в виде единого
API, что позволяет предоставить единые механизмы для управления,
встраивания прикладных программ в процесс аутентификации.  
PAM решает следующие задачи:  
Authentication - Аутентификация, идентификация, процесс
подтверждения пользователем своей “подлинности”, ввод логина
и пароля;  
Authorization - Авторизация, процесс наделения пользователя
правами (предоставления доступа к каким-либо объектам);  
Accounting - Запись информации о произошедших событиях.  
  
</details>

### Реализуем несколько способов решения задачи

<details>
  <summary>Модуль pam_time</summary>
  
  + Настройки данного модуля хранятся в файле /etc/security/time.conf
  + Добавим в конец файла строки:  
    ```
    *;*;day;Al0800-2000  
    *;*;night;!Al0800-2000  
    *;*;friday;Fr  
    ```
    Разные параметры отделяются символом ";". Разберем первую
строку:

```
- “*” сервис, к которому применяется правило
- "*" имя терминала, к которому применяется правило
- имя пользователя (day), для которого данное правило будет действовать
- время (Al0800-2000), когда правило носит разрешающий характер
```
+ Теперь настроим PAM, так как по-умолчанию данный модуль не
подключен. Для этого приведем файл /etc/pam.d/sshd к виду:

```
account     required    pam_nologin.so
account     required    pam_time.so
```

+ Проверяем в отдельном терминале доступ к
серверу по ssh для созданных пользователей  

!!! В методичке было указано настроить /etc/pam.d/sshd
Не отрабатывало, пока не настроил - **/etc/pam.d/login**

У-успех
![Альтернативный текст](https://i.ibb.co/DRMZpBS/1234.png)
</details>

<details>
  <summary>Модуль pam_exec</summary>

+ Переустановил ВМ
+ В /etc/pam.d/sshd внес изменения:
```
account required pam_nologin.so  
account required pam_exec.so /usr/local/bin/test_login.sh
```
+ [test_login.sh](test_login.sh) 
<details>
  <summary>Про скрипт</summary>

При запуске данного скрипта PAM-модулем будет передана
переменная окружения PAM_USER, содержащая имя пользователя.
Скрипт содержит простую логику. Если имя пользователя friday, то
проверям день недели, если пятница, то возвращаем 0, если нет, то
1 и завершаем скрипт.
Если же указан другой пользователь, то в строке
is_day_hours=$(($(test $hour -ge 8; echo $?)+$(test $hour -lt
20; echo $?)))
происходит проверка принадлжит ли текущее значение времени
(переменная hour) диапазону от 8 до 20 часов. Если да, то
is_day_hours примет значение 0, если нет 1. Дальше проверяем имя
пользователя и соотвествие ему. Если пользователь day и часы
"дневные", то возвращаем 0, если пользователь night и часы НЕ
дневные, то так же возвращаем ноль. В противном случае скрипт
вернет 1. Если в PAM_USER указано какое-то другое имя пользователя,
то скрипт вернет 0.
На основании кода завершения скрипта модуль pam_exec принимает
решение. Если вернулся 0, то все в порядке и пользователь будет
авторизован, в обратном случае нет.

</details>
</details>

<details>
  <summary>Права администратора</summary>

Помимо внесения ограничений на вход пользователя в систему, мы
так же можем предоставить выбранному пользователю разные
права. Для примера рассмотрим предоставление прав root'а
определеному пользователю в системе. Обычно для этого
используются следующие варианты:  
+ пользователь заносится в группу wheel;
+ для него создается отдельный файл в /etc/sudoers.d/;
+ отдельная строка в /etc/sudoers.
Первый способ реализуется очень просто. Зайдя в систему под
root'ом нужно выполнить:  
**usermod -G wheel day**
Теперь зайдя в систему под пользователем **day** можно выполнить
команду **sudo -i** и получить консоль пользователя **root**. При этом
будет запрошен пароль того пользователя, под которым
осуществлен вход в систему (в данном случае **day**).

</details>

### Дать конкретному пользователю права работать с докером и возможность рестартить докер сервис

**Время интересного :)**

Просматривая лекцию, я понял, что задание со звездочкой я выполню на раз-два, так как преподаватель показал как его выполнять.

Но не тут то было.

Испытания проводил на версии ubuntu 18.04

Создал директорию /etc/polkit-1/rules.d

Написал условие

```
polkit.addRule(function(action, subject) {
    if (action.id == "org.freedesktop.systemd1.manage-units") {
        if (action.lookup("unit") == "docker.service" && subject.user === "roman"){
            if (action.lookup("verb") == "restart") {
                return polkit.Result.YES;
            }
        }
    }
});
```
![Альтернативный текст](https://i.ibb.co/QfbtLy1/1234.png)

Ошибка

Помогло решение из https://unix.stackexchange.com/questions/496982/restarting-systemd-service-only-as-a-specific-user

Проблема крылась в версии polkit

![Альтернативный текст](https://i.ibb.co/vLX0XBB/1234.png)

```
root@matveevs:/etc/polkit-1/localauthority/50-local.d# cat org.freedesktop.systemd1.pkla 
[Allow user roman to run systemctl commands]
Identity=unix-user:roman
Action=org.freedesktop.systemd1.manage-units
ResultInactive=no
ResultActive=no
ResultAny=yes

```

![Альтернативный текст](https://i.ibb.co/gtH6mPt/1234.png)

Задачу со * считаю выполненным на 50%, так как данное условие позволяется управлять не только сервисом докера.